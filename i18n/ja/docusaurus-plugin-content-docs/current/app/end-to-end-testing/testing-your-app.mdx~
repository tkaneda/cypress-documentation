---
title: '効果的なE2E: Cypressアプリテスト'
sidebar_label: '自前のアプリをテストする'
description: 'Cypressアプリテストガイドで効果的なエンドツーエンドテスト戦略を発見して、テストの習熟度をアップさせよう'
sidebar_position: 20
slug: /app/end-to-end-testing/testing-your-app
---

# 自前のアプリをテストする

:::info

##### <Icon name="question-circle" color="#4BBFD2" /> ここで学ぶこと

- サーバを開始して、Cypressを使ってアプリケーションをテストする方法
- Cypress の設定方法
- データのシーディング、サーバのスタブ方法、ログイン方法を含む、アプリケーションをテストする上での戦略
  :::

## <Icon name="terminal" /> ステップ1: サーバを起動する

プロジェクトにはすでに、
[Cypressのインストール](/app/get-started/install-cypress)と
[Cypressをオープンする](/app/get-started/open-the-app)が無事終わっていると仮定して、
まずやるべきことは、アプリケーションをホストするローカルの開発サーバを起動することだ。

おそらく、**http://localhost:8080**のようになるはず。

:::caution

<strong>アンチパターン</strong>

Cypressスクリプトからウェブサーバを起動しようとしないこと。詳細については、
[ベストプラクティス](/app/core-concepts/best-practices#Web-Servers)を参照してほしい。

:::

### なぜローカルの開発サーバを起動するのか？

なぜすでに本番環境にあるアプリケーションにアクセスするべきじゃないのか？と疑問に思っているかもしれない。

すでにデプロイされているアプリケーションをテストすることは確かに可能ではあるが、
それはCypressの**スイートスポット**ではない。

Cypressは毎日のローカル開発のためのツールとして構築され、最適化されている。
実際、Cypress を使い始めた後しばらくは、
**すべての開発**をCypressで行うことですら有用であることがわかるだろう。

究極的には、**テストと開発**を同時に行うことができるだけでなく、テストを「無料で」実施しながら、アプリケーションを**より迅速に**構築できるようになる。

さらに、Cypressを使えば、**スタブネットワークリクエスト**などを実行できるので、有効なJSONレスポンスを返すサーバを必要とせずに、ウェブアプリケーションを構築することができる。

最後になったが、すでに構築されたアプリケーションにテストを押し付けようとするのは、テストを書きながら構築するよりもはるかに難しい。最初からテストを書いていれば回避できたであろう一連の初期の課題、ハードルに遭遇する可能性がある。

ローカルサーバに対してテストを行う上での、最後の、おそらく最も重要な理由は、**ローカルサーバを制御**できることにある。アプリケーションを本番環境で実行している場合、それを制御することはできない。

開発環境でアプリケーションを実行している場合、下記のことが可能になる:

- ショートカットする
- 実行可能スクリプトの実行によるデータのシード
- テスト環境固有のルーティングの公開
- 自動化を困難にするセキュリティ機能を無効にする
- サーバ／データベースの状態をリセットする

そうは言っても、**両方の方法**を選択することも可能だ。

多くのユーザはローカル開発サーバに対して_大部分の_統合テストを実行するが、デプロイされた本番アプリケーションに対してのみ実行される数少ない一連の**スモークテスト**を予約する。

## <Icon name="globe" /> ステップ2: サーバにアクセスする

サーバを起動したら、それにアクセスする。

前のチュートリアルで作成された`spec.cy.js`ファイルを削除しよう。いまはもう不要だ。

```shell
rm cypress/e2e/spec.cy.js
```

`home_page.cy.js`という独自のスペックファイルを作成しよう。

```shell
touch cypress/e2e/home_page.cy.js
```

このファイルを作成したら、スペックファイルのリストに表示されるはずだ。

<DocsImage
  src="/img/app/get-started/e2e/v10/testing-your-app-home-page-spec.png"
  alt="List of files including home_page.cy.js"
  width="75%"
/>

ここで、サーバにアクセスするためのテストファイルに、下記のコードを追加する必要がある:

```js
describe('The Home Page', () => {
  it('successfully loads', () => {
    cy.visit('http://localhost:8080') // change URL to match your dev URL
  })
})
```

ここで`home_page.cy.js`ファイルをクリックするとCypressがブラウザをオープンする。

サーバを起動し忘れてたら、下記のエラーになるはずだ。

<!--
To reproduce the following screenshot:
it('successfully loads', () => {
  cy.visit('https://localhost:8080')
})
-->

<DocsImage
  src="/img/app/get-started/e2e/v10/testing-your-app-visit-fail.png"
  alt="Error in Cypress showing cy.visit failed"
  width="75%"
/>

サーバをすでに起動していたら、アプリケーションがロードされ機能しているのがわかるはずだ。

## <Icon name="cogs" /> ステップ3: Cypressを設定する

先々のことを考えると、すべてのテストがアプリケーションの何らかのページにアクセスする必要があるので、このURLを頻繁にタイプすることになることにすぐに気づくだろう。幸いにも、Cypress にはこのための[設定オプション](/app/references/configuration)が用意されている。すぐにこれを活用しよう。

[設定ファイル](/app/references/configuration)をオープンしよう。
最初は空っぽだが、`baseUrl`オプションを追加しよう。

:::cypress-config-example

```ts
{
  e2e: {
    baseUrl: 'http://localhost:8080'
  }
}
```

:::

This will automatically **prefix** [`cy.visit()`](/api/commands/visit) and
[`cy.request()`](/api/commands/request) commands with this baseUrl.

:::info

Whenever you modify your configuration file, Cypress will automatically reboot
itself and kill any open browsers. This is normal. Click on the spec file again
to relaunch the browser.

:::

We can now visit a relative path and omit the hostname and port.

```js
describe('The Home Page', () => {
  it('successfully loads', () => {
    cy.visit('/')
  })
})
```

Great! Everything should still be green.

:::info

<strong>Configuration Options</strong>

Cypress has many more configuration options you can use to customize its
behavior. Things like where your tests live, default timeout periods,
environment variables, which reporter to use, etc.

Check them out in [Configuration](/app/references/configuration)!

:::

## Testing strategies

You're about to embark on writing tests for your application, and only _you_
know your application, so we don't have a lot of specific advice to give you.

**What to test, where the edge cases and seams are, what regressions you're
likely to run into, etc. are entirely up to you, your application, and your
team.**

That said, modern web testing has a few wrinkles that every team experiences, so
here are some quick tips on common situations you're likely to run into.

### Seeding data

Depending on how your application is built - it's likely that your web
application is going to be affected and controlled by the server.

Typically these days servers communicate with front end apps via JSON, but you
could also be running a traditional server-side rendered HTML web application.

Generally the server is responsible for sending responses that reflect some kind
of **state** it holds - generally in a database.

Traditionally when writing `e2e` tests using Selenium, before you automate the
browser you do some kind of **set up and tear down** on the server.

Perhaps you'll need to generate a user, and seed them with associations and
records. You may be familiar with using things such as fixtures or factories.

To test various page states - like an empty view, or a pagination view, you'd
need to seed the server so that this state can be tested.

**While there is a lot more to this strategy, you generally have three ways to
facilitate this with Cypress:**

- [`cy.exec()`](/api/commands/exec) - to run system commands
- [`cy.task()`](/api/commands/task) - to run code in Node via the
  [setupNodeEvents](/app/plugins/plugins-guide#Using-a-plugin) function
- [`cy.request()`](/api/commands/request) - to make HTTP requests

If you're running `node.js` on your server, you might add a `before` or
`beforeEach` hook that executes an `npm` task.

```js
describe('The Home Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')
  })

  it('successfully loads', () => {
    cy.visit('/')
  })
})
```

Instead of just executing a system command, you may want more flexibility and
could expose a series of routes only when running in a test environment.

**For instance, you could compose several requests together to tell your server
exactly the state you want to create.**

```js
describe('The Home Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')

    // seed a post in the DB that we control from our tests
    cy.request('POST', '/test/seed/post', {
      title: 'First Post',
      authorId: 1,
      body: '...',
    })

    // seed a user in the DB that we can control from our tests
    cy.request('POST', '/test/seed/user', { name: 'Jane' })
      .its('body')
      .as('currentUser')
  })

  it('successfully loads', () => {
    // this.currentUser will now point to the response
    // body of the cy.request() that we could use
    // to log in or work with in some way

    cy.visit('/')
  })
})
```

While there's nothing really _wrong_ with this approach, it does add a lot of
complexity. You will be battling synchronizing the state between your server and
your browser - and you'll always need to set up / tear down this state before
tests (which is slow).

The good news is that we aren't Selenium, nor are we a traditional e2e testing
tool. That means we're not bound to the same restrictions.

**With Cypress, there are several other approaches that can offer an arguably
better and faster experience.**

### Stubbing the server

Another valid approach opposed to seeding and talking to your server is to
bypass it altogether.

While you'll still receive all of the regular HTML / JS / CSS assets from your
server and you'll continue to [`cy.visit()`](/api/commands/visit) it in the same
way - you can instead **stub** the JSON responses coming from it.

This means that instead of resetting the database, or seeding it with the state
we want, you can force the server to respond with **whatever** you want it to.
In this way, we not only prevent needing to synchronize the state between the
server and browser, but we also prevent mutating state from our tests. That
means tests won't build up state that may affect other tests.

Another upside is that this enables you to **build out your application**
without needing the _contract_ of the server to exist. You can build it the way
you want the data to be structured, and even test all of the edge cases, without
needing a server.

However - there is likely still a balance here where **both** strategies are
valid (and you should likely do them).

While stubbing is great, it means that you don't have the guarantees that these
response payloads actually match what the server will send. However, there are
still many valid ways to get around this:

#### Generate the fixture stubs ahead of time

You could have the server generate all of the fixture stubs for you ahead of
time. This means their data will reflect what the server will actually send.

#### Write a single e2e test without stubs, and then stub the rest

Another more balanced approach is to integrate both strategies. You likely want
to have a **single test** that takes a true `e2e` approach and stubs nothing.
It'll use the feature for real - including seeding the database and setting up
state.

Once you've established it's working you can then use stubs to test all of the
edge cases and additional scenarios. There are no benefits to using real data in
the vast majority of cases. We recommend that the vast majority of tests use
stub data. They will be orders of magnitude faster, and much less complex.

:::info

<strong>Guide: Network Requests</strong>

Please read our [Guide on Network Requests](/app/guides/network-requests) for
a much more thorough analysis and approach to accomplishing this.

:::

### Logging in

One of the first (and arguably one of the hardest) hurdles you'll have to
overcome in testing is logging into your application.

Nothing slows a test suite down like having to log in, but all the good parts of
your application most likely require an authenticated user! Here are some tips.

#### Fully test the login flow -- but only once!

It's a great idea to get your signup and login flow under test coverage since it
is very important to all of your users and you never want it to break.

Logging in is one of those features that are **mission critical** and should
likely involve your server. We recommend you test signup and login using your UI
as a real user would:

Here's an example alongside seeding your database:

```js
describe('The Login Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')

    // seed a user in the DB that we can control from our tests
    // assuming it generates a random password for us
    cy.request('POST', '/test/seed/user', { username: 'jane.lane' })
      .its('body')
      .as('currentUser')
  })

  it('sets auth cookie when logging in via form submission', function () {
    // destructuring assignment of the this.currentUser object
    const { username, password } = this.currentUser

    cy.visit('/login')

    cy.get('input[name=username]').type(username)

    // {enter} causes the form to submit
    cy.get('input[name=password]').type(`${password}{enter}`)

    // we should be redirected to /dashboard
    cy.url().should('include', '/dashboard')

    // our auth cookie should be present
    cy.getCookie('your-session-cookie').should('exist')

    // UI should reflect this user being logged in
    cy.get('h1').should('contain', 'jane.lane')
  })
})
```

You'll likely also want to test your login UI for:

- Invalid username / password
- Username taken
- Password complexity requirements
- Edge cases like locked / deleted accounts

Each of these likely requires a full blown e2e test.

#### Reusing the login code

At this point there's nothing stopping you copying and pasting the login code
above into every one of your tests that needs an authenticated user. Or you
could even put all your tests in one big spec file and put the login code in a
`beforeEach` block. But neither of those approaches is particularly
maintainable, and they're certainly not very elegant. A much better solution is
to write a custom `cy.login()` [command](/api/cypress-api/custom-commands).

Custom commands allow you to easily encapsulate and reuse Cypress test logic.
They let you add your own functionality to your test suite and then use it with
the same
[chainable and asynchronous API](/app/core-concepts/introduction-to-cypress#The-Cypress-Command-Queue)
as the built-in Cypress commands. Lets make the above login example a custom
command and add it to `cypress/support/commands.js` so it can be leveraged in
any spec file:

```js
// In cypress/support/commands.js

Cypress.Commands.add('login', (username, password) => {
  cy.visit('/login')

  cy.get('input[name=username]').type(username)

  // {enter} causes the form to submit
  cy.get('input[name=password]').type(`${password}{enter}`, { log: false })

  // we should be redirected to /dashboard
  cy.url().should('include', '/dashboard')

  // our auth cookie should be present
  cy.getCookie('your-session-cookie').should('exist')

  // UI should reflect this user being logged in
  cy.get('h1').should('contain', username)
})

// In your spec file

it('does something on a secured page', function () {
  const { username, password } = this.currentUser
  cy.login(username, password)

  // ...rest of test
})
```

#### Improving performance

You're probably wondering what happened to our advice about logging in "only
once". The custom command above will work just fine for testing your secured
pages, but if you have more than a handful of tests, logging in before every
test is going to increase the overall run time of your suite.

Luckily, Cypress provides the [`cy.session()`](/api/commands/session) command, a
powerful performance tool that lets you cache the browser context associated
with your user and reuse it for multiple tests without going through multiple
login flows! Let's modify the custom `cy.login()` command from our previous
example to use `cy.session()`:

```js
Cypress.Commands.add('login', (username, password) => {
  cy.session(
    username,
    () => {
      cy.visit('/login')
      cy.get('input[name=username]').type(username)
      cy.get('input[name=password]').type(`${password}{enter}`, { log: false })
      cy.url().should('include', '/dashboard')
      cy.get('h1').should('contain', username)
    },
    {
      validate: () => {
        cy.getCookie('your-session-cookie').should('exist')
      },
    }
  )
})
```

:::info

<strong>Third-Party Login</strong>

If your app implements login via a third-party authentication provider such as
[Auth0](https://auth0.com/) or [Okta](https://www.okta.com/), you can use the
[`cy.origin()`](/api/commands/origin) command to include their login pages as
part of your authentication tests.

:::

There's a lot going on here that's out of the scope for this introduction.
Please check out the [`cy.session()`](/api/commands/session) documentation for a
more in-depth explanation.

:::info

<strong>Authentication Recipes</strong>

Logging in can be more complex than what we've just covered.

We've created several recipes covering additional scenarios like dealing with
CSRF tokens or testing XHR based login forms.

Feel free to [explore these additional logging in](/app/references/recipes) recipes.

:::

## Get started

Ok, we're done talking. Now dive in and get started testing your app!

From here you may want to explore some more of our guides:

- [Cypress API](/api/table-of-contents) to learn what commands are available as
  you work
- [Introduction to Cypress](/app/core-concepts/introduction-to-cypress)
  explains how Cypress _really_ works
- [Command Line](/app/references/command-line) for running all your tests outside
  via `cypress run`
- [Continuous Integration](/app/continuous-integration/overview) for
  running Cypress in CI
- [Cross Browser Testing](/app/guides/cross-browser-testing) for optimally
  running tests in CI across Firefox and Chrome-family browsers
- <Icon name="github" inline="true" contentType="rwa" /> demonstrations of Cypress
  testing practices, configuration, and strategies in a real-world project.
